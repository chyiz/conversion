
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <semaphore.h>

#include "ksnap.h"
#include "shmUtility.h"
#include "ftrace.h"

//what should the size of the metadata segment be?
int __compute_meta_data_pages(int size_in_bytes){
  int total_pages = (size_in_bytes/(KSNAP_PAGE_SIZE))+1;
  //add 2 extra pages, 1 for ksnap_meta_data and 1 to be safe for dirty pages
  int meta_data_pages = (total_pages/KSNAP_PAGE_SIZE) + 2;
  return meta_data_pages;
}

size_t __get_file_size(int fd){
	size_t sizeInBytes=0;
	struct stat fileStats;
	if (fstat(fd,&fileStats) != -1){
		sizeInBytes=(fileStats.st_size > 0) ? fileStats.st_size : 0;
	}
	return sizeInBytes;
}

//we only want the file name...not a path
char * __strip_file_name(char * file_name){
  char * return_ptr=NULL;
  char ** file_name_ptr=&file_name;
  while(*file_name_ptr){
    return_ptr=strsep(file_name_ptr, "/");
  }
  return return_ptr;
}


void * __open_shared_memory_segment(int size_of_segment, char * file_name, void * desired_address, int * fd, int flags, int * created){
  void * mem;
  int tmp_fd, size_of_file;
  char file_path[200];
  int tries=0;

  if (fd==NULL){
    fd = &tmp_fd;
  }
 open:
  sprintf(file_path,"%s",file_name);
  *fd = open(file_path, O_RDWR, 0644);
  if (*fd==-1){
    *fd = open(file_path, O_CREAT | O_RDWR | O_EXCL, 0644);
    if (*fd < 0){
      ++tries;
      if (tries>5){
	printf("failed to open %s\n", file_name);
	exit(1);
      }
      goto open;
    }
    *created=1;
    if (*fd ==-1){
      fprintf(stderr, "failed to make file for kSnap segment %s\n", file_name);
      perror("huh?");
      exit(0);
    }
  }
  else{
    *created=0;
  }
  //printf("opened %s created %d\n", file_path, *created);
  size_of_file=__get_file_size(*fd);
  if (size_of_file==0){
    ftruncate(*fd, size_of_segment);
  }
  if (desired_address){
    flags |= MAP_FIXED;
  }
  mem = mmap(desired_address,size_of_segment,PROT_READ|PROT_WRITE,flags,*fd,0);
  if (!mem){
    fprintf(stderr, "failed mapping %s at %p\n", file_name, desired_address);
    exit(0);
  }
  return mem;
}

unsigned int __compute_dirty_list_length(unsigned int meta_data_pages){
  return (meta_data_pages - 1) * ((KSNAP_PAGE_SIZE/sizeof(unsigned long)) - 10);
}

unsigned int get_dirty_list_size(ksnap * snap){
  return __get_meta_local_page(snap)->dirty_page_count;
}

void __ksnap_open_meta_data_segments(int size_of_segment, char * segment_name, ksnap * snap){
  char meta_data_local_name[200];
  char meta_data_shared_name[200];
  sprintf(meta_data_local_name,"meta_local_%s_%d.mem", segment_name,getpid());
  sprintf(meta_data_shared_name,"meta_shared_%s.mem", segment_name);
  int meta_data_pages = __compute_meta_data_pages(size_of_segment);
  int created=0;
  //
  void * meta_data_local = __open_shared_memory_segment(meta_data_pages*KSNAP_PAGE_SIZE, 
							meta_data_local_name, snap->segment - (KSNAP_PAGE_SIZE*(meta_data_pages-1)) - (META_LOCAL_OFFSET_FROM_SEGMENT*KSNAP_PAGE_SIZE),
							NULL, MAP_PRIVATE, &created);
  if (created){
    memset(meta_data_local,0,meta_data_pages*KSNAP_PAGE_SIZE);
  }

  void * meta_data_shared = __open_shared_memory_segment(1*KSNAP_PAGE_SIZE, 
							 meta_data_shared_name, snap->segment - (META_SHARED_OFFSET_FROM_SEGMENT*KSNAP_PAGE_SIZE), 
							 NULL, MAP_SHARED, &created);

  if (created){
    memset(meta_data_shared,0,1*KSNAP_PAGE_SIZE);
  }

  //printf("THE snap is at %p, the meta_data_local is at %p, the meta_data_shared %p, meta pages %d\n\n", snap->segment, meta_data_local, meta_data_shared, meta_data_pages);
  //printf("metadatashared name %s\n", meta_data_shared_name);

  mlock(meta_data_local,meta_data_pages*KSNAP_PAGE_SIZE);
  mlock(meta_data_shared,1*KSNAP_PAGE_SIZE);
  __get_meta_local_page(snap)->meta_data_size = meta_data_pages;
  __get_meta_local_page(snap)->dirty_list_size = __compute_dirty_list_length(meta_data_pages);
}

//open up a snapshot, only to be called once on a snapshot
ksnap * ksnap_open(int size_of_segment, char * segment_name, int type_of_commit, void * desired_address){
  int meta_data_pages;
  int created;
  ksnap * snap = malloc(sizeof(ksnap));
  snap->name = malloc(100);
  snap->file_name = malloc(100);
  sprintf(snap->file_name, "%s.mem", segment_name);
  sprintf(snap->name, "%s", __strip_file_name(segment_name));
  
  //meta_data_pages = __compute_meta_data_pages(size_of_segment);
  snap->size_of_segment = size_of_segment;

  snap->segment = __open_shared_memory_segment(snap->size_of_segment, snap->file_name, desired_address, &snap->fd, MAP_PRIVATE, &created);

  madvise(snap->segment, snap->size_of_segment, MADV_KSNAP_ALWAYS);
  madvise(snap->segment, snap->size_of_segment, MADV_KSNAP_TRACK);
  //madvise(snap->segment, snap->size_of_segment, MADV_DONTFORK);
  __ksnap_open_meta_data_segments(size_of_segment, snap->name, snap);

  return snap;
}

//create the ksnap object, but don't open the segment yet
ksnap * ksnap_create_no_open(int size_of_segment, char * segment_name, int type_of_commit, int commit_interval, int process_type, void * desired_address){
  ksnap * snap = malloc(sizeof(ksnap));
  snap->name = malloc(100);
  snap->file_name = malloc(100);
  sprintf(snap->file_name, "%s.mem", segment_name);
  sprintf(snap->name, "%s", segment_name);
  
  snap->size_of_segment = size_of_segment;
  snap->segment = desired_address;
  return snap;
}

//what if we want to work with a segment that is already opened in our address space? This is useful for when we are using the
//malloc library and we don't have control (or full control) of the mmap() call and where it maps to. So, we have to go find the address
//so we can still call msync on it.
ksnap * ksnap_open_exisiting(char * segment_name, unsigned int policy){
  char * search_name[1000];
  FILE * fp;
  ksnap * snap;
  int pid = getpid();
  //a buffer for the command we need to run (a shell script with some input params)
  char command[200];
  //a buffer for storing the segment address we get
  char segment_address[20];
  
  sprintf(search_name, "%s.convmem", segment_name);

  sprintf(command,"find_snapshot_mapping.sh %d %s\n", pid, search_name); 
  fp = popen(command, "r");
  if (fp == NULL) {
    printf("failed to find snapshot, could not execute external shell.\n" );
    return NULL;
  }

  //get the segment address, the formula just *2 because it's in hex and 
  //-3 because proc doesn't seem to output the last 2 bytes (since it's obviously word aligned I guess)
  if (fgets(segment_address, (sizeof(void *)*2)-3, fp)==NULL){
    perror("failed to find existing snapshot\n");
    return NULL;
  }
  else{ 
    snap = malloc(sizeof(ksnap));
    snap->segment = (void *)strtol(segment_address, NULL, 16);
    snap->name = segment_name;
  }
  //now we need to get the size, so we grab the end address. There is a space in the output so the formula changes by 1
  if (fgets(segment_address, (sizeof(void *)*2)-2, fp)==NULL){
    perror("failed to find existing snapshot\n");
    return NULL;
  }
  else{
    unsigned long end_address = strtol(segment_address, NULL, 16);
    snap->size_of_segment=end_address - (unsigned long)snap->segment;
  }
  /* close */
  pclose(fp);
  //mark it as a snapshot
  madvise(snap->segment, snap->size_of_segment, policy);
  madvise(snap->segment, snap->size_of_segment, MADV_KSNAP_TRACK);

  __ksnap_open_meta_data_segments( snap->size_of_segment, segment_name, snap);
  //now try to open a metadata segment
  /*int meta_data_pages = __compute_meta_data_pages(snap->size_of_segment);
  char * meta_data_name[150];
  sprintf(meta_data_name,"meta_%s.mem", segment_name);
  void * meta_data =  coreUtil_openSharedMemory( meta_data_name, snap->segment-(KSNAP_PAGE_SIZE*meta_data_pages)-(META_OFFSET_FROM_SEGMENT*KSNAP_PAGE_SIZE), 
    meta_data_pages*KSNAP_PAGE_SIZE, SHM_CORE, NULL, COMMIT_NONE, 0);

  void * meta_data = __open_shared_memory_segment(meta_data_pages*KSNAP_PAGE_SIZE, 
						  meta_data_name, snap->segment-(KSNAP_PAGE_SIZE*meta_data_pages) - (META_OFFSET_FROM_SEGMENT*KSNAP_PAGE_SIZE), NULL, MAP_PRIVATE);

  memset(meta_data,0,meta_data_pages*KSNAP_PAGE_SIZE);
  mlock(meta_data, meta_data_pages*KSNAP_PAGE_SIZE);
  madvise(snap->segment, snap->size_of_segment, MADV_KSNAP_TRACK);
  __get_meta_page(snap)->meta_data_size = meta_data_pages;
  //__get_meta_page(snap)->dirty_list_size = __compute_dirty_list_size(meta_data_pages);
  __get_meta_page(snap)->dirty_list_size = 20;
  printf("EXISTING snap %p, meta %p %d\n", snap->segment, meta_data, meta_data_pages*KSNAP_PAGE_SIZE);*/
  return snap;
}


//lets update and get a new view of the snapshot
void ksnap_update(ksnap * snap, int debug_it){
  struct ftracer * tracer;
  if (debug_it){
    tracer=ftrace_init(tracer);
    ftrace_on(tracer);
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:CALLING UPDATE\n\n\n");
  }
  /*printf("BEFORE UPDATE:::shared....%d local %d pid %d\n", 
	 __get_meta_shared_page(snap)->snapshot_version_num,
	 __get_meta_local_page(snap)->snapshot_version_num,
	 getpid());*/

  if (__get_meta_shared_page(snap)->snapshot_version_num > __get_meta_local_page(snap)->snapshot_version_num){
    msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_GET);
    }
  /*printf("AFTER UPDATE:::shared....%d local %d pid %d\n", 
	 __get_meta_shared_page(snap)->snapshot_version_num,
	 __get_meta_local_page(snap)->snapshot_version_num,
	 getpid());*/
  if (debug_it){
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:DONE CALLING UPDATE\n\n\n");
    ftrace_off(tracer);
    ftrace_close(tracer);
  }
}

void ksnap_update_mutex(ksnap * snap, sem_t * sem){
  //printf("sem wait is %p....pid %d\n", sem, getpid());
  sem_wait(sem);
  ksnap_update(snap, KSNAP_NO_DEBUG);
}

//lets update and get a new view of the snapshot
void ksnap_merge(ksnap * snap, int debug_it){
  struct ftracer * tracer;
  if (debug_it){
    tracer=ftrace_init(tracer);
    ftrace_on(tracer);
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:CALLING UPDATE\n\n\n");
  }
  if (__get_meta_shared_page(snap)->snapshot_version_num > __get_meta_local_page(snap)->snapshot_version_num){
    msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_MERGE);
    }
  if (debug_it){
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:DONE CALLING UPDATE\n\n\n");
    ftrace_off(tracer);
    ftrace_close(tracer);
  }
}

void ksnap_update_barrier_determ(ksnap * snap){
  if (__get_meta_shared_page(snap)->snapshot_version_num > __get_meta_local_page(snap)->snapshot_version_num){
    msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_GET | KSNAP_SYNC_BARRIER_DETERM);
  }
}

void ksnap_merge_barrier_determ(ksnap * snap){
  if (__get_meta_shared_page(snap)->snapshot_version_num > __get_meta_local_page(snap)->snapshot_version_num){
    msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_MERGE | KSNAP_SYNC_BARRIER_DETERM);
  }
}

void ksnap_settle_barrier_determ(ksnap * snap){
  if (__get_meta_local_page(snap)->dirty_page_count > 0){
    msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_MAKE | KSNAP_SYNC_BARRIER_DETERM);
  }
}

void ksnap_settle(ksnap * snap, int debug_it){
  struct ftracer * tracer;
  if (debug_it){
    tracer=ftrace_init(tracer);
    ftrace_on(tracer);
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:CALLING SETTLE,\n\n\n"); 
  }

  msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_MAKE);

  /*printf("SETTLE:::shared....%d local %d pid %d\n", 
	 __get_meta_shared_page(snap)->snapshot_version_num,
	 __get_meta_local_page(snap)->snapshot_version_num,
	 getpid());*/

  if (debug_it){
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:DONE CALLING SETTLE\n\n\n");
    ftrace_off(tracer);
    ftrace_close(tracer);
  }
}

void ksnap_settle_mutex(ksnap * snap, sem_t * sem){
  ksnap_settle(snap, KSNAP_NO_DEBUG);
  //printf("sem post is %p....pid %d\n", sem, getpid());
  sem_post(sem);
}

void ksnap_settle_and_sync(ksnap * snap, int debug_it){
  struct ftracer * tracer;
  if (debug_it){
    tracer=ftrace_init(tracer);
    ftrace_on(tracer);
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:CALLING SETTLE,\n\n\n"); 
  }
  msync(snap->segment,snap->size_of_segment, KSNAP_SYNC_MAKE);
  msync(snap->segment,snap->size_of_segment, MS_SYNC);
  if (debug_it){
    ftrace_write_to_trace(tracer, "\n\nSNAPSHOT:DONE CALLING SETTLE\n\n\n");
    ftrace_off(tracer);
    ftrace_close(tracer);
  }
}
